1. [判定字符是否唯一](#判定字符是否唯一)
2. [判定是否互为字符重排](#判定是否互为字符重排)
3. [有效的字母异位词](#有效的字母异位词)
4. [两数之和](#两数之和)
5. [最长连续序列](#最长连续序列)
6. [反转字符串中的单词III](#反转字符串中的单词III) 
7. [移除元素](#移除元素) 
8. [左旋转字符串](#左旋转字符串) 
9. [移除重复节点](#移除重复节点) 
10. [Longest Common Substring](#Longest-Common-Substring) 
11. [Remove Duplicates from Sorted Array I](#Remove-Duplicates-from-Sorted-Array-I) 

### 判定字符是否唯一

```
实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
示例 1：
输入: s = "leetcode"
输出: false 
示例 2：
输入: s = "abc"
输出: true
```

```cpp
/*
times: ##
分析：
唯一性问题可考虑哈希表解决

*/
class Solution {
public:
    bool isUnique(string astr) {
        bitset<256> hashMap;
        for(int i{}; i < astr.length(); ++i) {
            if(hashMap[(int)astr[i]]) {
                return false;
            }
            hashMap[(int)astr[i]] = 1;
        }

        return true;
    }
};
```

### 判定是否互为字符重排

```
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

示例 1：
输入: s1 = "abc", s2 = "bca"
输出: true 

示例 2：
输入: s1 = "abc", s2 = "bad"
输出: false
```

```cpp
/*
times: ##
分析：
用哈希表统计两个字符串各字符个数，然后比较两个哈希表是否相等

*/
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        if(s1.length() != s2.length()) {
            return false;
        }

        unordered_map<char, int> hashMapA;
        unordered_map<char, int> hashMapB;
        for(int i{}; i < s1.length(); i++) {
            hashMapA[s1[i]]++;
            hashMapB[s2[i]]++;
        }
        if(hashMapA.size() != hashMapB.size()) {
            return false;
        }

        for(auto it = hashMapA.begin(); it != hashMapA.end(); ++it) {
            if(it->second != hashMapB[it->first]) {
                return false;
            }
        }

        return true;
    }
};
```

### 有效的字母异位词

```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false
```

```cpp
/*
times: ##
分析：
和字符重排一样，可用哈希表解决，用一个哈希表即可解决

*/
class Solution {
public:
    bool isAnagram(string s, string t) {
        // hashmap
        if(s.size() != t.size()) {
            return false;
        }

        int letterCount[256] = {0};
        for(int i{}; i < s.size(); i++) {
            ++letterCount[s[i]];
            --letterCount[t[i]];
        }

        for(int i{}; i < s.size(); i++) {
            if(letterCount[s[i]] > 0) {
                return false;
            } 
        }

        return true;

        // sort
        /*
        if(s.size() != t.size()) {
            return false;
        }

        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        if(s != t) {
            return false;
        }

        return true; */
    }
};
```

### 两数之和

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可以按任意顺序返回答案。

示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]

示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
```

```cpp
/*
times: ##
分析：
将元素作为哈希表键值，元素下标作为哈希表值，使用哈希表即可解决

*/
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // hashmap
        unordered_map<int, int> numToIndex;
        vector<int> vi(2);
        for(auto it = nums.begin(); it != nums.end(); ++it) {
            if(numToIndex.count(target - *it)) {
                vi[0] = numToIndex[target - *it];
                vi[1] = (int)(it - nums.begin());
                break;
            }
            numToIndex[*it] = (int)(it - nums.begin());
        }

        return vi;
    }
};
```

### 最长连续序列

```
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？

示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

```cpp
/*
times: ##
分析：
增加一个边界类，遍历数组元素，更新每个元素的边界值，并且更新连续数列的最大长度

*/
struct Bound { // 边界结构体，保存每个元素连续串的最远边界
    int high;
    int low;

    Bound(int h = 0, int l = 0) {
        high = h;
        low = l;
    }
};

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int, Bound> table;
        int local;
        int maxLen = 0;

        for(int i{}; i < nums.size(); ++i) {
            if(table.count(nums[i])) {
                continue; // 跳过重复元素
            }

            local = nums[i];
            int low = local, high = local;

            if(table.count(local-1)) {
                low = table[local-1].low;
            }
            if(table.count(local+1)) {
                high = table[local+1].high;
            }
			
            // 更新序列最小元素的最大边界和最大元素的最小边界
            table[low].high = table[local].high = high;
            table[high].low = table[local].low = low;

            if(high - low + 1 > maxLen) {
                maxLen = high - low + 1;
            }
        }

        return maxLen;
    }
};
```

### 反转字符串中的单词III

```
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

示例：
输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
```

```cpp
/*
times: #
分析：
反转字符串问题多种多样，工具函数反转单词，找到反转要求，注意字符串结尾没有空格标记，需要特殊处理

*/
class Solution {
public:
    string reverseWords(string s) {
        int start = 0;

        for(int i{}; i < s.size(); ++i) {
            if(s[i] == ' ') {
                reverseWord(s, start, i - 1);
                start = i + 1;
            }
                
            if(i == s.size()-1) {
                reverseWord(s, start, i);
            }      
        }

        return s;
    }

    void reverseWord(string& str, int l, int r) {
        while(l < r) {
            swap(str[l], str[r]);
            l++;
            r--;
        }
        return;
    }
};
```

### 移除元素

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
```

```cpp
/*
times: #
分析：
注意使用vector容器函数，如果是数组类型，题目对移除后数组元素没有顺序要求，因此可将末尾元素往前移动，不允许开辟额外空间题目，可以考虑覆盖元素操作

*/
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        // vector
        /*
        for(auto it = nums.begin(); it != nums.end(); ++it) {
            if(*it == val) {
                nums.erase(it);
                --it;
            }
        }
        return nums.size();*/
        
        // array
        int len = nums.size();
        for(int i{}; i < len; ++i) {
            if(nums[i] == val) {
                nums[i] = nums[len-1];
                --i;
                --len;
            }
        }

        return len;
    }
};
```

### 左旋转字符串

```
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

示例 1：
输入: s = "abcdefg", k = 2
输出: "cdefgab"

示例 2：
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

```cpp
/*
times: #
分析：
固定类型题目，注意对n取余操作，防止数组访问越界

*/
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        if(s.empty() || n <= 0) {
            return s;
        }

        // 注意取余
        int offset = n % s.size();
        reverseString(s, 0, offset-1);
        reverseString(s, offset, s.size()-1);
        reverseString(s, 0, s.size()-1);

        return s;
    }

    void reverseString(string& str, int left, int right) {
        while(left < right) {
            swap(str[left], str[right]);
            left++;
            right--;
        }
    }
};
```

### 移除重复节点

```
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
 
示例2:
 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

```cpp
/*
times: #
分析：
使用哈希表记录元素出现与否

*/
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == NULL) {
            return head;
        }

        vector<bool> exist(20000, false);
        ListNode* pTmp = head;
        while(pTmp && pTmp->next) {
            exist[pTmp->val] = true;
            if(exist[pTmp->next->val]) {
                pTmp->next = pTmp->next->next;
                //continue;
            }
            else {
                pTmp = pTmp->next;
            }
        }

        return head;
    }
};
```

### Longest Common Substring

```
A = "ABCD", B = "CBCE"
return 2.
```

```cpp
/*
times: #
分析：
暴力解法，三层循环

*/
int longestCommonSubstring(string& A, string& B) {
	if(A.empty() || B.empty()) {
        return 0;
	}   
    
    int lcs = 0, lcs_temp = 0;
    for(int i = 0; i < A.size(); ++i) {
        for(int j = 0; j < B.size(); ++j) {
            lcs_temp = 0;
            while((i+lcs_temp < A.size()) && 
                  (j+lcs_temp < B.size()) && 
                  (A[i+lcs_temp] == B[j+lcs_temp])) {
                ++lcs_temp;
            }
            
            // update lcs
            if(lcs_temp > lcs) {
                lcs = lcs_temp;
            }
        }
    }
    
    return lcs;
}
```

### Remove Duplicates from Sorted Array I

```
nums = [1, 1, 2]
return 2
```

```cpp
/*
times: #
分析：
有序数组移除重复元素，双指针思想，采用覆盖元素避免分配额外空间

*/
int removeDuplicates(vector<int>& nums) {
    if(nums.empty()) {
        return 0;
    }
    
    int size = 0;
    for(int i{}; i < nums.size(); ++i) {
        if(num[i] != nums[size]) {
            nums[++size] = nums[i];
        }
    }
    
    return ++size;
}
```