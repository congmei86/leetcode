### 判定字符是否唯一

```
实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
示例 1：
输入: s = "leetcode"
输出: false 
示例 2：
输入: s = "abc"
输出: true
```

```cpp
/*
times: #
分析：
唯一性问题可考虑哈希表解决

*/
class Solution {
public:
    bool isUnique(string astr) {
        bitset<256> hashMap;
        for(int i{}; i < astr.length(); ++i) {
            if(hashMap[(int)astr[i]]) {
                return false;
            }
            hashMap[(int)astr[i]] = 1;
        }

        return true;
    }
};
```

### 判定是否互为字符重排

```
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

示例 1：
输入: s1 = "abc", s2 = "bca"
输出: true 

示例 2：
输入: s1 = "abc", s2 = "bad"
输出: false
```

```cpp
/*
times: #
分析：
用哈希表统计两个字符串各字符个数，然后比较两个哈希表是否相等

*/
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        if(s1.length() != s2.length()) {
            return false;
        }

        unordered_map<char, int> hashMapA;
        unordered_map<char, int> hashMapB;
        for(int i{}; i < s1.length(); i++) {
            hashMapA[s1[i]]++;
            hashMapB[s2[i]]++;
        }
        if(hashMapA.size() != hashMapB.size()) {
            return false;
        }

        for(auto it = hashMapA.begin(); it != hashMapA.end(); ++it) {
            if(it->second != hashMapB[it->first]) {
                return false;
            }
        }

        return true;
    }
};
```

### 有效的字母异位词

```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false
```

```cpp
/*
times: #
分析：
和字符重排一样，可用哈希表解决，用一个哈希表即可解决

*/
class Solution {
public:
    bool isAnagram(string s, string t) {
        // hashmap
        if(s.size() != t.size()) {
            return false;
        }

        int letterCount[256] = {0};
        for(int i{}; i < s.size(); i++) {
            ++letterCount[s[i]];
            --letterCount[t[i]];
        }

        for(int i{}; i < s.size(); i++) {
            if(letterCount[s[i]] > 0) {
                return false;
            } 
        }

        return true;

        // sort
        /*
        if(s.size() != t.size()) {
            return false;
        }

        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        if(s != t) {
            return false;
        }

        return true; */
    }
};
```

### 两数之和

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可以按任意顺序返回答案。

示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]

示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
```

```cpp
/*
times: #
分析：
将元素作为哈希表键值，元素下标作为哈希表值，使用哈希表即可解决

*/
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // hashmap
        unordered_map<int, int> numToIndex;
        vector<int> vi(2);
        for(auto it = nums.begin(); it != nums.end(); ++it) {
            if(numToIndex.count(target - *it)) {
                vi[0] = numToIndex[target - *it];
                vi[1] = (int)(it - nums.begin());
                break;
            }
            numToIndex[*it] = (int)(it - nums.begin());
        }

        return vi;
    }
};
```

### 最长连续序列

```
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？

示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

```cpp
/*
times: #
分析：
增加一个边界类，遍历数组元素，更新每个元素的边界值，并且更新连续数列的最大长度

*/
struct Bound { // 边界结构体，保存每个元素连续串的最远边界
    int high;
    int low;

    Bound(int h = 0, int l = 0) {
        high = h;
        low = l;
    }
};

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int, Bound> table;
        int local;
        int maxLen = 0;

        for(int i{}; i < nums.size(); ++i) {
            if(table.count(nums[i])) {
                continue; // 跳过重复元素
            }

            local = nums[i];
            int low = local, high = local;

            if(table.count(local-1)) {
                low = table[local-1].low;
            }
            if(table.count(local+1)) {
                high = table[local+1].high;
            }
			
            // 更新序列最小元素的最大边界和最大元素的最小边界
            table[low].high = table[local].high = high;
            table[high].low = table[local].low = low;

            if(high - low + 1 > maxLen) {
                maxLen = high - low + 1;
            }
        }

        return maxLen;
    }
};
```

