1. [最小栈](#最小栈)
2. [用栈实现队列](#用栈实现队列)
3. [栈排序](#栈排序)
4. [有效的括号](#有效的括号)
5. [二叉树的中序遍历](#二叉树的中序遍历)
6. [逆波兰表达式求值](#逆波兰表达式求值)

### 最小栈

```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
```

```cpp
/* 	times: #
	分析：两种处理方法，用一个栈或者两个栈，合理使用数据结构
*/
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        if(minStack.empty() || x <= minStack.top()) {
            minStack.push(x);
        }
        valueStack.push(x);
    }
    
    void pop() {
        if(valueStack.empty()) return;
        if(valueStack.top() == minStack.top()) {
            minStack.pop();
        }
        valueStack.pop();
    }
    
    int top() {
        return valueStack.top();
    }
    
    int getMin() {
        return minStack.top();
    }

private:
    stack<int> valueStack;
    stack<int> minStack;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */

class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        if(x < min) {
            min = x;
        }
        minStack.push(make_pair(min, x));
    }
    
    void pop() {
        minStack.pop();
        if(minStack.empty()) {
            min = INT_MAX;
        }
        else {
            min = minStack.top().first;
        }
    }
    
    int top() {
        return minStack.top().second;
    }
    
    int getMin() {
        return minStack.top().first;
    }

private:
    int min = INT_MAX;
    stack<pair<int, int>> minStack;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 用栈实现队列

```
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
```

```cpp
/* 	times: #
	分析：
*/
class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stk1st.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(stk2nd.empty()) {
            while(!stk1st.empty()) {
                stk2nd.push(stk1st.top());
                stk1st.pop();
            }
        }

        int elem = stk2nd.top();
        stk2nd.pop();
        return elem;
    }
    
    /** Get the front element. */
    int peek() {
        if(stk2nd.empty()) {
            while(!stk1st.empty()) {
                stk2nd.push(stk1st.top());
                stk1st.pop();
            }
        }

        return stk2nd.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return stk1st.empty() && stk2nd.empty();
    }

private:
    stack<int> stk1st;
    stack<int> stk2nd;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

### 栈排序

```
栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。
```

```cpp
/* 	times: #
	分析：
*/
class SortedStack {
public:
    SortedStack() {

    }
    
    void push(int val) {
        if(stk1st.empty()) {
            stk1st.push(val);
        }
        else {
            while(!stk1st.empty() && stk1st.top() < val) {
                stk2nd.push(stk1st.top());
                stk1st.pop();
            }
            stk1st.push(val);
            while(!stk2nd.empty()) {
                stk1st.push(stk2nd.top());
                stk2nd.pop();
            }
        }
    }
    
    void pop() {
        if(stk1st.empty()) return;
        stk1st.pop();
    }
    
    int peek() {
        if(stk1st.empty()) return -1;
        return stk1st.top();
    }
    
    bool isEmpty() {
        return stk1st.empty();
    }

private:
    stack<int> stk1st;
    stack<int> stk2nd;
};

/**
 * Your SortedStack object will be instantiated and called as such:
 * SortedStack* obj = new SortedStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->isEmpty();
 */
```

### 有效的括号

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
 
示例 1：
输入：s = "()"
输出：true

示例 2：
输入：s = "()[]{}"
输出：true

示例 3：
输入：s = "(]"
输出：false
```

```cpp
/* 	times: #
	分析：拆分问题求解
*/
class Solution {
public:
    bool isValid(string s) {
        stack<char> parentheses;
        for(auto& elem: s) {
            if(isLeftParentheses(elem)) {
                parentheses.push(elem);
            }
            else {
                if(parentheses.empty() || !isMatch(parentheses.top(), elem)) {
                    return false;
                }
                parentheses.pop();
            }
        }

        return parentheses.empty();
    }

    bool isLeftParentheses(char input) {
        return input == '(' || input == '{' || input == '[';
    }

    bool isMatch(char left, char right) {
        switch(left) {
            case '(':
                return right == ')';
            case '{':
                return right == '}';
            case '[':
                return right == ']';
        }
        return false;
    }
};
```

### 二叉树的中序遍历

```
给定一个二叉树的根节点 root ，返回它的 中序 遍历。

示例 1：
输入：root = [1,null,2,3]
输出：[1,3,2]
```
![](images/inorder_1.jpg)
```cpp
/* 	times: #
	分析：理解遍历树的递归思想
*/
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        if(!root) return result;

        stack<TreeNode*> stk;
        TreeNode* rt = root;
        while(rt || !stk.empty()) {
            while(rt) {
                stk.push(rt);
                rt = rt->left;
            }

            rt = stk.top();
            stk.pop();
            result.emplace_back(rt->val);
            rt = rt->right;
        }

        return result;
    }
};
```

### 逆波兰表达式求值

```
根据 逆波兰表示法，求表达式的值。
有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 

说明：
整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

```cpp
/* 	times: #
	分析：代码要细致，if...else的关系，以及switch...break
*/
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int res = 0;
        if(tokens.empty()) return res;
        
        stack<int> data;
        for(auto& str: tokens) {
            if(isOper(str)) {
                int right = data.top();
                data.pop();
                int left = data.top();
                data.pop();
                int result = calExpression(left, right, str);
                data.push(result);
            }
            else {
                data.push(atoi(str.c_str()));
            }
        }
        res = data.top();
        return res;
    }
    bool isOper(string str) {
        return str == "+" || str == "-" || str == "*" || str == "/";
    }

    int calExpression(const int left, const int right, string oper) {
        int result = 0;

        switch(oper[0]) {
            case '+':
                result = left + right;
                break;
            case '-':
                result = left - right;
                break;
            case '*':
                result = left * right;
                break;
            case '/':
                result = left / right;
                break;
        }
        return result;
    }     
};
```